# https://www.acmicpc.net/problem/1987

# DFS 스택으로 풀이 시도 -> 실패
import sys
input = sys.stdin.readline

r, c = map(int, input().split())
board = []
for _ in range(r):
    board.append(input())

dx = [-1, 0, 1, 0]
dy = [0, 1, 0, -1]
def dfs(x, y, visited):
    result = []
    for i in range(4):
        nx = x + dx[i]
        ny = y + dy[i]
        if nx < 0 or nx >= r or ny < 0 or ny >= c:
            continue
        if not board[nx][ny] in visited:
            result.append((nx,ny))
    return result

max_num = 0
i = 0
stack = [(0,0)]
count = 0
visited = board[0][0]
while stack:
    print(stack)
    count += 1
    if count > 6:
        break
    x, y = stack.pop()
    visited = visited[:-1]
    print(x, y, visited)
    max_num = max(max_num, len(visited))

    for i in range(4):
        nx = x + dx[i]
        ny = y + dy[i]
        if nx < 0 or nx >= r or ny < 0 or ny >= c:
            continue
        if not board[nx][ny] in visited:
            stack.append((x,y))
            stack.append((nx,ny))
            visited+=board[nx][ny]
            break

print(max_num)

# 집합, 스택으로 풀이
import sys
input = sys.stdin.readline

r, c = map(int, input().split())
board = []
for _ in range(r):
    board.append(input())

dx = [-1, 0, 1, 0]
dy = [0, 1, 0, -1]
def dfs(x, y, visited):
    result = []
    for i in range(4):
        nx = x + dx[i]
        ny = y + dy[i]
        if nx < 0 or nx >= r or ny < 0 or ny >= c:
            continue
        if not board[nx][ny] in visited:
            result.append((nx,ny))
    return result

max_num = 0
queue = set([(0,0,board[0][0])])
while queue:
    x, y, visited = queue.pop()
    max_num = max(max_num, len(visited))
    for i, j, in dfs(x, y, visited):
        queue.add((i,j,visited+board[i][j]))
print(max_num)


# 알파벳 아스키코드 리스트 풀이
import sys
input = sys.stdin.readline

r, c = map(int, input().split())
board = [list(map(lambda x:ord(x)-65, input().rstrip())) for _ in range(r)]
alpha = [False]*26
max_num = 0
def dfs(x, y, cnt):
    alpha[board[x][y]] = True

    global max_num
    max_num = max(cnt, max_num)
    if max_num >= 26:
        return

    dx = [-1, 0, 1, 0]
    dy = [0, 1, 0, -1]
    for i in range(4):
        nx = x + dx[i]
        ny = y + dy[i]
        if nx < 0 or nx >= r or ny < 0 or ny >= c:
            continue
        if not alpha[board[nx][ny]]:
            dfs(nx, ny, cnt+1)
            alpha[board[nx][ny]] = False


dfs(0,0, 1)
print(max_num)
