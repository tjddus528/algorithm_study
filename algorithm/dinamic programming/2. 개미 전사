# 혼자 풀이
가장 많은 식량을 약탈하기 위해서는 1칸을 띄거나 2칸을 뛰거나 최대한 많은 칸을 약탈해야 한다고 생각했음
그래서 현재 도달한 식량 창고를 무조건 약탈한다는 전제 하에 2칸 전 혹은 최대 3칸 전 창고 중 더 큰 값과 더해야 한다고 생각
즉, 많은 식량을 약탈하기 위해서는 약탈하는 식량 창고 사이의 칸수가 2를 넘어서는 안된다
(그리고 이 풀이에서 d는 해당 식량을 약탈했을 때를 전제로 지금까지 약탈할 수 있는 식량의 최댓값을 의미함)

8
19 10 7 9 1 5 7 4 의 경우 약탈할 수 있는 최대 식량은 37이다. 2개의 식량창고를 약탈하고 그 사이에는 3칸이 떨어져 있다.
19, 9, 5, 4 를 선택

n = int(input())
data = list(map(int, input().split()))

d = [0] * 101

d[0] = data[0]
d[1] = data[1]
d[2] = d[0] + data[2]

for i in range(3, n):
    d[i] = max(d[i-2], d[i-3]) + data[i]

print(max(d[n-2], d[n-1]))

# 책에서의 풀이
왼쪽부터 차례대로 식량창고를 턴다고 가정
식량창고를 털지 안 털지 결정하는 경우와 특정한 i번째 식량창고에 대해서 털지 안 털지의 여부를 결정할 때, 단 2가지의 경우에 대해서 확인
(이 풀이에서 d는 현재 식량을 약탈할지 말지에 대한 두가지 경우의 수 중 더 큰 값, 즉, 최대한 많은 식량을 약탈하기 위해 지금까지 훔친 식량의 수를 의미)

n = int(input())
data = list(map(int, input().split()))

d = [0] * 101

d[0] = data[0]
d[1] = max(data[0], data[1])

for i in range(2, n):
    d[i] = max(d[i-1], d[i-2] + data[i])

for i in range(n):
    print(d[i])

print(d[n-1])
